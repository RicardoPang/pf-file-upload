## 项目总结

1. 使用了什么技术

- 使用Vue3 Composition API和Pinia来管理全局状态
- 使用ts做类型声明，起到类型约束效果
- 使用Vue Router 4 来管理路由
- 使用Element Plus 来做UI组件库
- 使用Vite来进行开发和构建
- 使用koa开发服务端，增加config，全局异常拦截，日志等能力

2. 系统关键设计说明

- koa实现服务端，设置config，全局异常拦截，日志。addControllers自带哦国内读取controllers目录下所有文件，然后注册路由。通过middleware灵活设置content-type。
- 通过单例模式封装全局store，实现file size的存取
- 封装axios网络请求，API相关操作抽为独立api文件维护，所有请求使用store管理
- 使用worker计算文件hash
- 封装Scheduler实现并发控制，每次最多只能上传3个切片
- 将待上传和已上传封装成组件
- 体验优化（拖拽，进度条）
- 异步任务并发数，切片报错处理

3. 关键流程图
   [简单流程](https://www.yuque.com/u1598738/ryg73d/bz327udm30r7eiyy)

4. 过程中遇到什么问题

- 合并切片时机，前端判断所有切片都已上传完成后，发送请求通知服务端
- 服务端合并切片，使用stream
- 前端如何发送网络请求，为什么要封装axios，api独立抽离，封装后如果换库只需要改封装的文件,状态和操作可以不用都放在一个文件中
- worker生成hash，不阻塞主线程，标识文件唯一性
- 断点，使用AbortController取消切片上传
- 续传，服务端将已上传的切片返回，前端对比只上传剩余切片
- 秒传，hash相同直接反馈秒传
- 打开页面没有状态，增加接口获取上传文件
- 文件上传速度慢，通过实现文件分片上传、worker计算hash和多线程上传解决了问题
- 并发太多http请求，建立TCP卡死？并发控制，每次只能同时发起3个请求
- 跨域资源共享（CORS）问题，在vite配置文件设置server
- koa服务端没有config，全局异常拦截，日志等能力
- 魔数太多不好维护，可读性差，推荐明确对象结构
- 设置koaBody不够通用，通过传入middleware灵活设置
- 虽然启用ts，但是很多做类型声明，类型约束，使用any太多
- 操作文件使用同步方法，最好用fs promises处理
- ESM和CJS混用，只用ESM
- 函数名风格不统一，用驼峰命名法
- 全局变量保存属性，系统重启状态会丢失，做全局store，单例，封装读写行为
- 主页面UI结构复杂，状态太多，应拆分、抽组件
- api相关操作混在一起，代码混乱，应作为独立api文件维护

## 一期项目问题

1. 架构分层模糊，模块之间耦合度极高；
2. 存在许多基础问题，如命名风格；
3. 全局状态使用的非常随便，缺乏设计
